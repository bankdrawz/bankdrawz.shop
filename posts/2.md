---
title: "Leveraging Next.js API Routes for Backend Functionality"
date: "2023-11-25"
excerpt: "Explore how to use Next.js API routes to create powerful backend functionality within your frontend application, with real-world examples."
category: "Next.js"
featured: true
---

# Leveraging Next.js API Routes for Backend Functionality

Next.js API routes provide a powerful way to build backend functionality directly within your Next.js application. In this article, I'll show you how to make the most of this feature.

## What Are API Routes?

API routes allow you to create API endpoints as part of your Next.js application. Any file inside the `pages/api` directory (or `app/api` in the App Router) is treated as an API endpoint instead of a page.

## Basic Example

Let's start with a simple API route:

```typescript
// pages/api/hello.ts
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  message: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

## Request Methods

API routes support all HTTP methods. You can handle different methods in a single file:

```typescript
// pages/api/users.ts
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  switch (req.method) {
    case 'GET':
      // Handle GET request
      return res.status(200).json({ users: ['John', 'Jane'] })
    case 'POST':
      // Handle POST request
      return res.status(201).json({ message: 'User created' })
    default:
      res.setHeader('Allow', ['GET', 'POST'])
      return res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}
```

## Dynamic API Routes

You can create dynamic API routes using the same file naming pattern as dynamic pages:

```typescript
// pages/api/users/[id].ts
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query
  
  res.status(200).json({ id, name: `User ${id}` })
}
```

## Working with App Router

In the App Router, API routes work slightly differently. They use Route Handlers instead:

```typescript
// app/api/hello/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json({ message: 'Hello from Next.js App Router!' })
}

export async function POST(request: Request) {
  const body = await request.json()
  return NextResponse.json({ received: body })
}
```

## Middleware for API Routes

You can create middleware functions to handle common tasks like authentication:

```typescript
// middleware/withAuth.ts
import type { NextApiRequest, NextApiResponse } from 'next'

export function withAuth(
  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    // Check for auth token
    const token = req.headers.authorization
    
    if (!token) {
      return res.status(401).json({ message: 'Unauthorized' })
    }
    
    // Call the original handler
    return handler(req, res)
  }
}
```